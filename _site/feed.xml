<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>黄欢的博客</title>
    <description>美团金融后台研发工程师</description>
    <link>http://localhost:4000/HuangHuanBlog/</link>
    <atom:link href="http://localhost:4000/HuangHuanBlog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 05 Aug 2018 21:31:28 +0800</pubDate>
    <lastBuildDate>Sun, 05 Aug 2018 21:31:28 +0800</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>Spring条件初始化资源</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#概述&quot; id=&quot;markdown-toc-概述&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#说明&quot; id=&quot;markdown-toc-说明&quot;&gt;说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#方法一spring-profile&quot; id=&quot;markdown-toc-方法一spring-profile&quot;&gt;方法一：Spring Profile&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#profile配置&quot; id=&quot;markdown-toc-profile配置&quot;&gt;Profile配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#启用特定的profile&quot; id=&quot;markdown-toc-启用特定的profile&quot;&gt;启用特定的Profile&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#方法二spring-conditional&quot; id=&quot;markdown-toc-方法二spring-conditional&quot;&gt;方法二：Spring Conditional&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;

&lt;p&gt;在项目中会有依据一定条件来初始化Bean的需求，特别是在分Module的代码中，底层Module实现了对各种资源的封装，比如DB，Thrift，MQ，Http，调度任务等，但是上层的需求多种多样，比如有的Module只需要使用Thrift，但由于其依赖的底层Module封装了所有的资源，导致在上层Module运行时，除了Thrift，实际还初始化了DB，MQ，Http等资源，这不仅是种不必要的浪费，有时还可能带来问题。因此，本文将主要探讨如何能依据一定的条件，按需初始化Bean，以避免不必要的浪费。&lt;/p&gt;

&lt;h3 id=&quot;说明&quot;&gt;说明&lt;/h3&gt;

&lt;p&gt;范例项目通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Main&lt;/code&gt;函数启动项目，项目结构参考，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;Db.java，Http.java，Kafka.java&lt;/code&gt;代表三种不同的资源，它们在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;时会打印日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── example
    │   │           └── foo
    │   │               ├── Boot.java
    │   │               └── beans
    │   │                   ├── Db.java
    │   │                   ├── Http.java
    │   │                   └── Kafka.java
    │   └── resources
    │       ├── applicationContext.xml

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationContext.xml&lt;/code&gt;文件内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Spring基础配置 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:aop=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 类增强代理（而不是基于java的接口代理） --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;aop:aspectj-autoproxy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;proxy-target-class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启动类&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot.java&lt;/code&gt;内容为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;springframework&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;/**&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;启动类&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huanhuang&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boot&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;classpath:applicationContext.xml&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;资源代码以&lt;code class=&quot;highlighter-rouge&quot;&gt;Db.java&lt;/code&gt;为例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Db {

    public void init() {
        System.out.println(&quot;Db has bean initialized&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;方法一spring-profile&quot;&gt;方法一：Spring Profile&lt;/h3&gt;

&lt;p&gt;Profile的概念其实很常见，比如Maven也有，大家一般用Maven的Profile来管理不同环境的配置文件。但我自己之前有一个误区，以为Spring的Profile只能选者一种特定的Profile，但实际上它是支持同时指定多种Profile的，这就带来了很大的灵活性，下面介绍如何基于Spring Profile来条件初始化资源，先列下项目结构，主要多了一个配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;enableProfiles.properties&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── example
    │   │           └── foo
    │   │               ├── Boot.java
    │   │               └── beans
    │   │                   ├── Db.java
    │   │                   ├── Http.java
    │   │                   └── Kafka.java
    │   └── resources
    │       ├── applicationContext.xml
    │       └── enableProfiles.properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;profile配置&quot;&gt;Profile配置&lt;/h4&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationContext.xml&lt;/code&gt;文件中为不同的资源指定了Profile:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Spring基础配置 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:aop=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 类增强代理（而不是基于java的接口代理） --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;aop:aspectj-autoproxy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;proxy-target-class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;profile=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;enableDb&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.foo.beans.Db&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;init-method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;init&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;profile=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;enableHttp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.foo.beans.Http&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;init-method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;init&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;profile=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;enableKafka&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.foo.beans.Kafka&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;init-method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;init&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;启用特定的profile&quot;&gt;启用特定的Profile&lt;/h4&gt;

&lt;p&gt;这里我们把启用的profile放在了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;enableProfiles.properties&lt;/code&gt;文件里，内容为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enableProfiles=enableDb,enableKafka
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;表明我们只启用&lt;code class=&quot;highlighter-rouge&quot;&gt;Db&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Kafka&lt;/code&gt;资源，这里要注意的一点是，从结果来看，需要在Spring初始化之前，设置选用好Profile，&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot.java&lt;/code&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 启动类
 *
 * @author huanhuang
 */
public class Boot {
    public static void main(String[] args) {
        try {
            Properties properties = PropertiesLoaderUtils
            .loadAllProperties(&quot;enableProfiles.properties&quot;);
            String enableProfiles = properties.getProperty(&quot;enableProfiles&quot;);
            System.out.println(enableProfiles);
            System.setProperty(
            AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME, enableProfiles);
        } catch (IOException e) {
            e.printStackTrace();
        }
        ClassPathXmlApplicationContext context =
                new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);
        context.start();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码里我们首先手动读取了&lt;code class=&quot;highlighter-rouge&quot;&gt;enableProfiles.properties&lt;/code&gt;文件，然后最关键的代码在于下面一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.setProperty(AbstractEnvironment.ACTIVE_PROFILES_PROPERTY_NAME, enableProfiles);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个设定了一个环境变量，实际对应是的是&lt;code class=&quot;highlighter-rouge&quot;&gt;spring.profiles.active&lt;/code&gt;，最后运行结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Db has bean initialized
Kafka has bean initialized
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;符合预期，只有&lt;code class=&quot;highlighter-rouge&quot;&gt;Db&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Kafka&lt;/code&gt;被启用了，这种方式简单明了。&lt;/p&gt;

&lt;h3 id=&quot;方法二spring-conditional&quot;&gt;方法二：Spring Conditional&lt;/h3&gt;

&lt;p&gt;Spring的&lt;code class=&quot;highlighter-rouge&quot;&gt;@Conditional&lt;/code&gt;注解也就是依据一定的条件去初始化Bean，实际上Spring 4之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;@Profile&lt;/code&gt;注解就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Conditional&lt;/code&gt;来实现的，基于&lt;code class=&quot;highlighter-rouge&quot;&gt;@Conditional&lt;/code&gt;注解，实际上想怎么初始化资源都可以，Profile实际知识它的一个Feature。这个工具非常强大，唯一的问题是貌似不支持XML。下面是使用这种方式的代码结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com
│   │   │       └── example
│   │   │           └── foo
│   │   │               ├── Boot.java
│   │   │               ├── beans
│   │   │               │   ├── Db.java
│   │   │               │   ├── Http.java
│   │   │               │   └── Kafka.java
│   │   │               └── config
│   │   │                   ├── Config.java
│   │   │                   ├── DbCondition.java
│   │   │                   ├── HttpCondition.java
│   │   │                   └── KafkaCondition.java
│   │   └── resources
│   │       └── applicationContext.xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;@Conditional&lt;/code&gt;是注解，所以Bean的初始化也就通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;来实现了，需要配置&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationContext.xml&lt;/code&gt;如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Spring基础配置 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:aop=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd 
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 类增强代理（而不是基于java的接口代理） --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;aop:aspectj-autoproxy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;proxy-target-class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;base-package=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.foo&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bean的初始化在&lt;code class=&quot;highlighter-rouge&quot;&gt;Config.java&lt;/code&gt;中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Configuration
public class Config {

    @Bean(initMethod = &quot;init&quot;)
    @Conditional(DbCondition.class)
    public Db db() {
        return new Db();
    }

    @Bean(initMethod = &quot;init&quot;)
    @Conditional(HttpCondition.class)
    public Http http() {
        return new Http();
    }

    @Bean(initMethod = &quot;init&quot;)
    @Conditional(KafkaCondition.class)
    public Kafka kafka() {
        return new Kafka();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，我们可以给不同的资源使用不同的Condition，非常强大，当然自己得多写点代码，以&lt;code class=&quot;highlighter-rouge&quot;&gt;DbCondition.class&lt;/code&gt;为例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 启用Db的条件
 *
 * @author huanhuang
 */
public class DbCondition implements Condition {

    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要继承&lt;code class=&quot;highlighter-rouge&quot;&gt;Condition&lt;/code&gt;接口，然后这个方法里怎么匹配，自己想怎么写都可以，这里我只有&lt;code class=&quot;highlighter-rouge&quot;&gt;HttpCondition.class&lt;/code&gt;的方法返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，其它都是&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;，运行结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Http has bean initialized
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;Profile实际是Conditional的一个Feature，如果没有更复杂的需求，Profile就够用了，对于业务代码来讲Profile更容易理解，Conditional更适合于框架的场景。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Aug 2018 19:35:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/framework/2018/08/05/Spring%E6%9D%A1%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96Bean.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/framework/2018/08/05/Spring%E6%9D%A1%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96Bean.html</guid>
        
        
        <category>Framework</category>
        
      </item>
    
      <item>
        <title>折腾MacVim</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#概述&quot; id=&quot;markdown-toc-概述&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#阶段一需求&quot; id=&quot;markdown-toc-阶段一需求&quot;&gt;阶段一需求&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#阶段一效果&quot; id=&quot;markdown-toc-阶段一效果&quot;&gt;阶段一效果&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#对应配置&quot; id=&quot;markdown-toc-对应配置&quot;&gt;对应配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;

&lt;p&gt;用了一段时间的Atom莫名其妙的挂了，看网上推荐MacVim的不少，也想通过它弥补Vim编程不熟的遗憾，开始折腾一波MacVim。MacVim就是一个Mac OS上的自带编辑器加Vim的实现，命令和Vim是一样的。&lt;/p&gt;

&lt;h3 id=&quot;阶段一需求&quot;&gt;阶段一需求&lt;/h3&gt;

&lt;p&gt;分析一下自己对MacVim的需求，最后看下搞出来是个啥样子：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;目录树&lt;/li&gt;
  &lt;li&gt;代码补全&lt;/li&gt;
  &lt;li&gt;窗口分割和切换&lt;/li&gt;
  &lt;li&gt;状态栏&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;阶段一效果&quot;&gt;阶段一效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/macvim-stageOne.png&quot; alt=&quot;MacVim&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;对应配置&quot;&gt;对应配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot; *********************************************
&quot; Vbundle插件管理
&quot; *********************************************
set nocompatible              &quot; required
filetype off                  &quot; required

&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

&quot; alternatively, pass a path where Vundle should install plugins
&quot;call vundle#begin('~/some/path/here')

&quot; let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'
Plugin 'scrooloose/nerdtree'
Plugin 'Valloric/YouCompleteMe'
Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'

&quot; Add all your plugins here (note older versions of Vundle used Bundle instead of Plugin)
&quot; All of your Plugins must be added before the following line
call vundle#end()            &quot; required
filetype plugin indent on    &quot; required

&quot; ***************
&quot; 切换窗口键盘指令
&quot; ***************
&quot; 向下
nnoremap &amp;lt;C-J&amp;gt; &amp;lt;C-W&amp;gt;&amp;lt;C-J&amp;gt;
&quot; 向上
nnoremap &amp;lt;C-K&amp;gt; &amp;lt;C-W&amp;gt;&amp;lt;C-K&amp;gt;
&quot; 向右
nnoremap &amp;lt;C-L&amp;gt; &amp;lt;C-W&amp;gt;&amp;lt;C-L&amp;gt;
&quot; 向左
nnoremap &amp;lt;C-H&amp;gt; &amp;lt;C-W&amp;gt;&amp;lt;C-H&amp;gt;

&quot; **********************
&quot; 目录树插件NERDTree配置
&quot; **********************
&quot; 开启vim时默认开启NERDTree
au vimenter * NERDTree
&quot; 设置开启NERDTree快捷键
map &amp;lt;F2&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt;

&quot; ************
&quot; 代码补全相关
&quot; ************
let g:ycm_autoclose_preview_window_after_completion=1
&quot; 跳转到定义处
map &amp;lt;leader&amp;gt;g  :YcmCompleter GoToDefinitionElseDeclaration&amp;lt;CR&amp;gt;
&quot; 默认tab、s-tab和自动补全冲突
let g:ycm_key_list_select_completion = ['&amp;lt;TAB&amp;gt;', '&amp;lt;c-n&amp;gt;', '&amp;lt;Down&amp;gt;']
let g:ycm_key_list_previous_completion = ['&amp;lt;S-TAB&amp;gt;', '&amp;lt;c-p&amp;gt;', '&amp;lt;Up&amp;gt;']
let g:ycm_auto_trigger = 1

&quot; ***********
&quot; vim-airline
&quot; ***********
开启powerline字体
let g:airline_powerline_fonts = 1
&quot; 使用powerline包装过的字体
set guifont=Source\ Code\ Pro\ for\ Powerline:h14
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;需要主要的是装&lt;code class=&quot;highlighter-rouge&quot;&gt;YouCompleteMe&lt;/code&gt;后老是会有一个错误提示，&lt;code class=&quot;highlighter-rouge&quot;&gt;Error detected while processing function youcompleteme#Enable[3]..&amp;lt;SNR&amp;gt;&lt;/code&gt;，解决的办法是找到&lt;code class=&quot;highlighter-rouge&quot;&gt;YouCompleteMe&lt;/code&gt;对应的代码，将那个错误提示改掉，文件是&lt;code class=&quot;highlighter-rouge&quot;&gt;/autoload/youcompleteme.vim&lt;/code&gt;，改动如下代码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function! s:SetUpPython() abort
-  exec s:python_until_eof //原始代码
+  silent! exec s:python_until_eof //修改后代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 09 Jul 2018 20:05:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/develop/2018/07/09/MacVim.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/develop/2018/07/09/MacVim.html</guid>
        
        
        <category>Develop</category>
        
      </item>
    
      <item>
        <title>乐观锁&amp;悲观锁</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#什么是乐观锁悲观锁&quot; id=&quot;markdown-toc-什么是乐观锁悲观锁&quot;&gt;什么是乐观锁，悲观锁？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#乐观锁悲观锁举例&quot; id=&quot;markdown-toc-乐观锁悲观锁举例&quot;&gt;乐观锁，悲观锁举例&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#数据表&quot; id=&quot;markdown-toc-数据表&quot;&gt;数据表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#悲观锁实现&quot; id=&quot;markdown-toc-悲观锁实现&quot;&gt;悲观锁实现&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#代码&quot; id=&quot;markdown-toc-代码&quot;&gt;代码&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#结果&quot; id=&quot;markdown-toc-结果&quot;&gt;结果&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#乐观锁实现&quot; id=&quot;markdown-toc-乐观锁实现&quot;&gt;乐观锁实现&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#代码-1&quot; id=&quot;markdown-toc-代码-1&quot;&gt;代码&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#结果-1&quot; id=&quot;markdown-toc-结果-1&quot;&gt;结果&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#结果分析&quot; id=&quot;markdown-toc-结果分析&quot;&gt;结果分析&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是乐观锁悲观锁&quot;&gt;什么是乐观锁，悲观锁？&lt;/h2&gt;

&lt;p&gt;关于乐观锁和悲观锁的概念，网上有很多，概括一下是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;乐观锁：&lt;/strong&gt; 只会在数据最终提交的时候去锁定数据，判断是否可以更新&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;悲观锁：&lt;/strong&gt; 每次操作都会进行数据的锁定，直到处理完成，杜绝其它操作更改数据的可能。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;网上很多博客对乐观锁，悲观锁的区别写的很模糊，就我自己的理解，两者实际最终都会对数据加锁，区别在于锁定的时机，相比于乐观锁，悲观锁往往存在一个预先锁定数据，然后处理的逻辑，所以其持有锁的时间会更长，导致整体性能降低。悲观锁的好处是处理有序进行，多数请求都能成功，而乐观锁可能会导致大量的失败。&lt;/p&gt;

&lt;h2 id=&quot;乐观锁悲观锁举例&quot;&gt;乐观锁，悲观锁举例&lt;/h2&gt;

&lt;p&gt;关于概念就不再做赘述了，直接上代码看吧，这里以电商秒杀场景为例子，这个场景下用户查询量，下单量都会非常大。我们用MySQL来存储被秒杀的商品库存，分别用乐观锁和悲观锁方式来实现，最后对比两者性能。&lt;/p&gt;

&lt;h3 id=&quot;数据表&quot;&gt;数据表&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;product_stock&lt;/code&gt;用来存储产品的库存，&lt;code class=&quot;highlighter-rouge&quot;&gt;stock&lt;/code&gt;表示剩余商品的数量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Create Table: CREATE TABLE `product_stock` (
  `id` int(11) DEFAULT NULL,
  `product_id` int(11) DEFAULT NULL,
  `stock` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假设一共有&lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;个商品，这个活动要保证的有两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对用户响应快&lt;/li&gt;
  &lt;li&gt;不能超卖&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+------+------------+-------+
| id   | product_id | stock |
+------+------------+-------+
|    1 |          1 |    50 |
+------+------------+-------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pojo&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Stock {
    private int id;
    private int product_id;
    private int stock;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getProduct_id() {
        return product_id;
    }

    public void setProduct_id(int product_id) {
        this.product_id = product_id;
    }

    public int getStock() {
        return stock;
    }

    public void setStock(int stock) {
        this.stock = stock;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;悲观锁实现&quot;&gt;悲观锁实现&lt;/h3&gt;

&lt;p&gt;按悲观锁的思路，为了避免多个线程操作同一条数据导致的冲突，且为了避免超卖，同时应该只允许一个线程操作数据，并判断当前的库存。&lt;/p&gt;

&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Transactional(rollbackFor = Exception.class)
public void pessimistic() {
	/* 加锁查询库存，两个true参数表示加锁查主库，也就是for update操作 */
    Stock stock = stockMapper.selectByPrimaryKey(1, true, true);
    /* 判断是否还有剩余 */
    if (stock.getStock() &amp;lt;= 0) {
	System.out.println(&quot;已经抢完了:&quot; + System.currentTimeMillis() / 1000);
	return;
    }
    stock.setStock(stock.getStock() - 1);
    /* 更新库存 */
    stockMapper.updateByPrimaryKey(stock);
    System.out.println(&quot;抢到了，剩下:&quot; + stock.getStock() + 
    &quot; &quot; + System.currentTimeMillis() / 1000);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;每一个操作先加锁查出当前的库存，然后进行扣减并更新，可能有人会问：为什么要加锁查询？原因很简单，避免超卖。&lt;/p&gt;

&lt;h4 id=&quot;结果&quot;&gt;结果&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;抢到了，剩下:49 1526222452
抢到了，剩下:48 1526222452
抢到了，剩下:47 1526222452
抢到了，剩下:46 1526222452
抢到了，剩下:45 1526222452
...
已经抢完了:1526222467
已经抢完了:1526222467
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行过程中没有更新失败的情况，总耗时 &lt;strong&gt;15s&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;乐观锁实现&quot;&gt;乐观锁实现&lt;/h3&gt;

&lt;p&gt;乐观锁往往通过&lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;timestamp&lt;/code&gt;来实现，以&lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;为例，通过判断版本号，来确定是否可以更新数据，而在查询的时候带上这个&lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;即可，不需要加锁。在这个场景下，我们用一个Trick，把&lt;code class=&quot;highlighter-rouge&quot;&gt;stock&lt;/code&gt;字段当作版本号，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;stock&lt;/code&gt;正好每次扣减1，而且必须是连续的，所以每次更新时判断&lt;code class=&quot;highlighter-rouge&quot;&gt;stock&lt;/code&gt;值是否合法，然后进行减1更新操作。&lt;/p&gt;

&lt;h4 id=&quot;代码-1&quot;&gt;代码&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void optimistic() {
    /* 不用加锁查询数据 */
    Stock stock = stockMapper.selectByPrimaryKey(1, false, false);
    if (stock.getStock() &amp;lt;= 0) {
        System.out.println(&quot;抢完了:&quot; + System.currentTimeMillis() / 1000);
        return;
    }
    /* 抢库存，并同时更新，第一个参数是新的库存，第二个参数是当前查出的库存 */
    int value = stockMapper.updateStock(stock.getStock() - 1, stock.getStock());
    ／* 判断是否抢成功，1表示有一条记录被修改 */
    if (value == 1) {
        System.out.println(&quot;抢成功，剩下:&quot; + (stock.getStock() - 1) + &quot; &quot;
        + System.currentTimeMillis() / 1000);
    } else {
        System.out.println(&quot;抢失败:&quot; + System.currentTimeMillis() / 1000);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里有个区别的地方是用了&lt;code class=&quot;highlighter-rouge&quot;&gt;updateStock&lt;/code&gt;方法，这个方法对应的操作是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update product_stock
set
stock = #{newStock} #设置新的stock
where id = 1 and stock=#{oldStock} #只有传回的oldStock和当前stock相等的情况下才会更新
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;结果-1&quot;&gt;结果&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;抢成功，剩下:49 1526223502
抢失败:1526223502
抢失败:1526223502
抢失败:1526223502
抢失败:1526223502
抢失败:1526223502
抢失败:1526223502
抢失败:1526223502
抢失败:1526223502
抢失败:1526223502
抢成功，剩下:48 1526223502
...
抢完了:1526223505
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行过程中有&lt;strong&gt;361&lt;/strong&gt;个抢失败的情况，但总耗时&lt;strong&gt;3s&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;结果分析&quot;&gt;结果分析&lt;/h3&gt;

&lt;p&gt;从列子的结果来看：&lt;strong&gt;乐观锁的总耗时远远低于悲观锁的情况，但却导致了大量的更新失败，实际更新的次数也远高于（悲观锁也就会有50次更新操作）悲观锁&lt;/strong&gt;，其原因是因为乐观锁在查询库存时不需要加锁，这带来了查询性能的明显提升，但也导致了更多的更新操作（因为只有最后提交的时候，才知道是否能抢到并扣库存成功），这其实就是系统设计的&lt;code class=&quot;highlighter-rouge&quot;&gt;Tradeoff&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;可能有人会问，更新操作时MySQL加的排他锁不就是一种悲观锁吗，文中的乐观锁或悲观锁到数据库更新的时候不都是悲观的吗？其实我理解，乐观锁和悲观锁体现的是两种不同的设计思想，其粒度可以是数据库的锁设计，也可以是业务的处理逻辑，重点是两种思想的异同。&lt;/p&gt;
</description>
        <pubDate>Sun, 13 May 2018 11:13:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/mysql/2018/05/13/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/mysql/2018/05/13/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.html</guid>
        
        
        <category>MySQL</category>
        
      </item>
    
      <item>
        <title>Git笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#git-log&quot; id=&quot;markdown-toc-git-log&quot;&gt;Git Log&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#普通&quot; id=&quot;markdown-toc-普通&quot;&gt;普通&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#显示差异&quot; id=&quot;markdown-toc-显示差异&quot;&gt;显示差异&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#极简显示&quot; id=&quot;markdown-toc-极简显示&quot;&gt;极简显示&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#其它&quot; id=&quot;markdown-toc-其它&quot;&gt;其它&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git-tag&quot; id=&quot;markdown-toc-git-tag&quot;&gt;Git Tag&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git-reset&quot; id=&quot;markdown-toc-git-reset&quot;&gt;Git Reset&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git-grep&quot; id=&quot;markdown-toc-git-grep&quot;&gt;Git Grep&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#显示行号&quot; id=&quot;markdown-toc-显示行号&quot;&gt;显示行号&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#只显示文件名&quot; id=&quot;markdown-toc-只显示文件名&quot;&gt;只显示文件名&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#显示每个文件中匹配的个数&quot; id=&quot;markdown-toc-显示每个文件中匹配的个数&quot;&gt;显示每个文件中匹配的个数&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;git-log&quot;&gt;Git Log&lt;/h3&gt;

&lt;p&gt;查看Git的提交历史命令&lt;/p&gt;

&lt;h4 id=&quot;普通&quot;&gt;普通&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huanhuang@localhost:~/Study/HuangHuanBlog$ git log
commit 964268b3493e9245f94ca72029cea417a6898751 (HEAD -&amp;gt; gh-pages, origin/gh-pages, origin/HEAD)
Author: huanghuan02 &amp;lt;huanghuan02@meituan.com&amp;gt;
Date:   Thu May 3 20:15:23 2018 +0800

    修改错误拼写

commit 61660c4f8595d0c10abe77f56c77bb1c5f8c6d3d
Author: huanghuan02 &amp;lt;huanghuan02@meituan.com&amp;gt;
Date:   Wed May 2 09:28:13 2018 +0800

    更新图片

commit c98048b57e90c83fe0ed802d8cb4f1251a30076e
Author: huanghuan02 &amp;lt;huanghuan02@meituan.com&amp;gt;
Date:   Tue May 1 18:10:43 2018 +0800

    MySQL MVCC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;显示差异&quot;&gt;显示差异&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huanhuang@localhost:~/Study/HuangHuanBlog$ git log -p
commit 964268b3493e9245f94ca72029cea417a6898751 (HEAD -&amp;gt; gh-pages, origin/gh-pages, origin/HEAD)
Author: huanghuan02 &amp;lt;huanghuan02@meituan.com&amp;gt;
Date:   Thu May 3 20:15:23 2018 +0800

    修改错误拼写

&lt;span class=&quot;gh&quot;&gt;diff --git a/_posts/2018-05-01-MVCC.md b/_posts/2018-05-01-MVCC.md
index f74ba2a..ea4000a 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/_posts/2018-05-01-MVCC.md
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/_posts/2018-05-01-MVCC.md
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -80,7 +80,7 @@ MySQL的Innodb引擎支持多种事务隔离级别，而其中的RR级别（Repe
&lt;/span&gt;
 ![Transaction visibility](/HuangHuanBlog/pics/transaction_visibility.png)

&lt;span class=&quot;gd&quot;&gt;-通过上图（这个图是通过分析网上的一些博客内容得到的，和实际MySQL的逻辑细节可能不一致），在来分析上文提到的Case，由于事务B的事务ID不满足`read_id=tid||tid&amp;lt;min_tid`的条件，且该记录当前有`DATA_ROLL_PTP`，所以最后该事务B实际读取的是Undo Log中的记录：
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+通过上图（这个图是通过分析网上的一些博客内容得到的，和实际MySQL的逻辑细节可能不一致），在来分析上文提到的Case，由于事务B的事务ID不满足`read_id=tid||tid&amp;lt;min_tid`的条件，且该记录当前有`DATA_ROLL_PTR`，所以最后该事务B实际读取的是Undo Log中的记录：
&lt;/span&gt;
 | Primary Key | Time      | Name | DATA_TRX_ID | DATA_ROLL_PTR |
 | ----------- | --------- | ---- | ----------- | ------------- |

commit 61660c4f8595d0c10abe77f56c77bb1c5f8c6d3d
Author: huanghuan02 &amp;lt;huanghuan02@meituan.com&amp;gt;
Date:   Wed May 2 09:28:13 2018 +0800

    更新图片
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;极简显示&quot;&gt;极简显示&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huanhuang@localhost:~/Study/HuangHuanBlog$ git log --pretty=oneline
964268b3493e9245f94ca72029cea417a6898751 (HEAD -&amp;gt; gh-pages, origin/gh-pages, origin/HEAD) 
修改错误拼写
61660c4f8595d0c10abe77f56c77bb1c5f8c6d3d 更新图片
c98048b57e90c83fe0ed802d8cb4f1251a30076e MySQL MVCC
c39e07b51c14b6e966c1798be6cdf1531e36d925 内容优化
50eff98bc148a0fa76b8fdc06ce6a280f2f92e13 MySQL 5.7 死锁原因
22b08846d46eff65fd29c8482e4457267cefc287 whatever
821d18625f1653b612a4015f1bb97d67033ddedf 2018回归！
252854d2c2f2774ffa019c2e34130ae514b2b438 MOD:调整格式
d3e0962a1311a3edf723878e137929ecdd674c85 MOD:增加了第二周分析，完成了这篇博客
d3df279b4a82b74c4f49fade15a0ace4f18ffe79 ADD:第一周会计表
226fff7935518c1fc47b61b930a553cc8e4b1fd2 ADD:利润表
1f5f32ec1cd02ea4d266b5cb5f63753dee6e6637 ADD:会计小结
af3d7c86242238edd1a7e70410d15962f445b58f ADD:死锁章完成
2ecc010e50d5e28a40f8cb886c82811660e3008c ADD: Innodb范例
5a615870c3b795df2d73432b029a712633324eec ADD: Innodb死锁
bbad334d8249181f6254cc800e9fc0698c7538bb ADD: Innodb死锁
53f0015ee07a492847ad8d019ddbe154fe06d372 ADD: php自动化测试
f5f05d5aeb9f5d2baff09f13ce69233dc58cec6c MOD: 更新文档
f8f2acc032eefc2004dca42cd40ffd2af1344694 ADD: Innodb锁介绍
cae98b5c5d39e43b78489dd5ccfc48813f8d5d2c ADD: Innodb锁详细介绍
e3d233612b8b71326fa15d24765cd32392995cd8 ADD: maven docs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;其它&quot;&gt;其它&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#图形显示，也就是有个时间轴
git log --graph
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;git-tag&quot;&gt;Git Tag&lt;/h3&gt;

&lt;p&gt;Tag是打标签，可用来作为发布版本管理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#显示已有标签
git tag

#打标签
git tag -a tagName -m comment
git tag -a 0.5.5 -m '发布版 0.5.5'

#显示tag信息
git show 0.5.5

#推到服务器
git push origin 0.5.5

#本地删除和远程删除
git tag -d 0.5.5
git push origin :refs/tags/0.5.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;git-reset&quot;&gt;Git Reset&lt;/h3&gt;

&lt;p&gt;重置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#本地回滚到指定commit
git reset &amp;lt;commit&amp;gt;

#本地reset后远程同步
git push -f origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;git-grep&quot;&gt;Git Grep&lt;/h3&gt;

&lt;p&gt;代码搜索&lt;/p&gt;

&lt;p&gt;####搜索包含指定字符的文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huanhuang@localhost:~/Study/HuangHuanBlog$ git grep '2018'
_posts/2018-04-15-MySQL5.7问题.md:date:   2018-04-15 23:15 +0800
_posts/2018-05-01-MVCC.md:date:   2018-05-01 14:26 +0800
_posts/2018-05-01-MVCC.md:| 1           | 2018-4-28 | Huan | 1           | NULL          |
_posts/2018-05-01-MVCC.md:| 1           | 2018-4-28 | Huan | 1           | NULL          |
_posts/2018-05-06-Git.md:date:   2018-05-06 21:05:00 +0800
_posts/2018-05-06-Git.md:Date:   Thu May 3 20:15:23 2018 +0800
_posts/2018-05-06-Git.md:Date:   Wed May 2 09:28:13 2018 +0800
_posts/2018-05-06-Git.md:Date:   Tue May 1 18:10:43 2018 +0800
_posts/2018-05-06-Git.md:Date:   Thu May 3 20:15:23 2018 +0800
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;显示行号&quot;&gt;显示行号&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huanhuang@localhost:~/Study/HuangHuanBlog$ git grep -n '2018'
_posts/2018-04-15-MySQL5.7问题.md:4:date:   2018-04-15 23:15 +0800
_posts/2018-05-01-MVCC.md:4:date:   2018-05-01 14:26 +0800
_posts/2018-05-01-MVCC.md:66:| 1           | 2018-4-28 | Huan | 1           | NULL          |
_posts/2018-05-01-MVCC.md:87:| 1           | 2018-4-28 | Huan | 1           | NULL          |
_posts/2018-05-06-Git.md:4:date:   2018-05-06 21:05:00 +0800
_posts/2018-05-06-Git.md:19:Date:   Thu May 3 20:15:23 2018 +0800
_posts/2018-05-06-Git.md:25:Date:   Wed May 2 09:28:13 2018 +0800
_posts/2018-05-06-Git.md:31:Date:   Tue May 1 18:10:43 2018 +0800
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;只显示文件名&quot;&gt;只显示文件名&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huanhuang@localhost:~/Study/HuangHuanBlog$ git grep --name-only '2018'
_posts/2018-04-15-MySQL5.7问题.md
_posts/2018-05-01-MVCC.md
_posts/2018-05-06-Git.md
_posts/2018-05-13-乐观锁和悲观锁.md
_site/develop/2018/05/06/Git.html
_site/feed.xml
_site/index.html
_site/mysql/2018/04/15/MySQL5.7问题.html
_site/mysql/2018/05/01/MVCC.html
_site/mysql/2018/05/13/乐观锁和悲观锁.html
_site/page2/index.html
_site/page3/index.html
_site/page4/index.html
_site/read/2017/06/19/会计学入门小结.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;显示每个文件中匹配的个数&quot;&gt;显示每个文件中匹配的个数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;huanhuang@localhost:~/Study/HuangHuanBlog$ git grep -c '2018'
_posts/2018-04-15-MySQL5.7问题.md:1
_posts/2018-05-01-MVCC.md:3
_posts/2018-05-06-Git.md:38
_posts/2018-05-13-乐观锁和悲观锁.md:1
_site/develop/2018/05/06/Git.html:13
_site/feed.xml:25
_site/index.html:16
_site/mysql/2018/04/15/MySQL5.7问题.html:3
_site/mysql/2018/05/01/MVCC.html:6
_site/mysql/2018/05/13/乐观锁和悲观锁.html:3
_site/page2/index.html:8
_site/page3/index.html:8
_site/page4/index.html:8
_site/read/2017/06/19/会计学入门小结.html:1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 06 May 2018 21:05:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/develop/2018/05/06/Git.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/develop/2018/05/06/Git.html</guid>
        
        
        <category>Develop</category>
        
      </item>
    
      <item>
        <title>MySQL MVCC介绍</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#mvcc是什么&quot; id=&quot;markdown-toc-mvcc是什么&quot;&gt;MVCC是什么？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mvcc的效果&quot; id=&quot;markdown-toc-mvcc的效果&quot;&gt;MVCC的效果&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql的mvcc&quot; id=&quot;markdown-toc-mysql的mvcc&quot;&gt;MySQL的MVCC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mvcc是什么&quot;&gt;MVCC是什么？&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;MVCC的全称是Multi-Version Concurrency Control，通常用于数据库等场景中，实现多版本的并发控制&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果没有并发控制，那么如果同时有用户读写数据，那么可能出现读出的数据不一致的情况。比如说，进行银行账户A到B的转账，当A账户的钱被扣掉，而钱还没有加到B账户，此时用户查看自己的余额，会感觉钱凭空消失了。MySQL的隔离性就是用来解决这类问题的，而隔离性是通过不同的并发控制手段来实现的。对于刚才的问题，一种简单的并发控制方式，就是讲读写操作串行化，在账户间转账时，不允许查询账户，虽然这种方式可以解决问题，但无疑过于简单粗暴，效率极低。相比于串行化的并发控制，MVCC的优势在于读写影响，对于现代互联网读多写少的场景，这种方式性能明显更高。&lt;/p&gt;

&lt;p&gt;MVCC是通过保存数据的多个版本来实现并发控制，当需要更新某条数据时，实现了MVCC的存储系统不会立即用新数据覆盖原始数据，而是创建该条记录的一个新的版本。对于多数数据库系统，存储会分为&lt;code class=&quot;highlighter-rouge&quot;&gt;Data Part&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Undo Log&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Data Part&lt;/code&gt;用来存储事务已提交的数据，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Undo Log&lt;/code&gt;用来存储旧版本的数据。多版本的存在允许了读和写的分离，读操作是需要读取某个版本之前的数据即可，和写操作不冲突，大大提高了性能。&lt;/p&gt;

&lt;h2 id=&quot;mvcc的效果&quot;&gt;MVCC的效果&lt;/h2&gt;

&lt;p&gt;假如MVCC是按照时间来判定数据的版本，在Time=1的时刻，数据库的状态如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;Record A&lt;/th&gt;
      &lt;th&gt;Record B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;“Record A When time=0”&lt;/td&gt;
      &lt;td&gt;“Record B when time=0”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;“Record A When time=1”&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个时候系统中实际存储了三条记录，&lt;code class=&quot;highlighter-rouge&quot;&gt;Record A&lt;/code&gt;在时间0和1的各一条记录，&lt;code class=&quot;highlighter-rouge&quot;&gt;Record B&lt;/code&gt;的一条记录，如果一个事务在Time=0的时刻开启，那么读到的数据是：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Record A&lt;/th&gt;
      &lt;th&gt;Record B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“Record A When time=0”&lt;/td&gt;
      &lt;td&gt;“Record B when time=0”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果这个事务在Time=1的时候开启，那么读到的数据是：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Record A&lt;/th&gt;
      &lt;th&gt;Record B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“Record A When time=1”&lt;/td&gt;
      &lt;td&gt;“Record B when time=0”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上面的Case可以看到，对于读来讲，事务只能读到某一个版本及这个版本之前的最新一条数据，假如在Time=2的时候，事务&lt;code class=&quot;highlighter-rouge&quot;&gt;Transaction X&lt;/code&gt;要插入&lt;code class=&quot;highlighter-rouge&quot;&gt;Record C&lt;/code&gt;，并更新&lt;code class=&quot;highlighter-rouge&quot;&gt;Record B&lt;/code&gt;，但事务还未提交，那么数据库的状态如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;Record A&lt;/th&gt;
      &lt;th&gt;Record B&lt;/th&gt;
      &lt;th&gt;Record C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;“Record A When time=0”&lt;/td&gt;
      &lt;td&gt;“Record B when time=0”&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;“Record A When time=1”&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2(Not Committed)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;“Record B when time=2”&lt;/td&gt;
      &lt;td&gt;“Record C When time=2”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这时候其它事务会读到的是什么了？在这个情况下，其它读事务所能看到系统的最新版本是系统处于Time=1的时候，所以依然不会读到&lt;code class=&quot;highlighter-rouge&quot;&gt;Transaction X&lt;/code&gt;所改写的数据，此时读到的数据依然为：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Record A&lt;/th&gt;
      &lt;th&gt;Record B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“Record A When time=1”&lt;/td&gt;
      &lt;td&gt;“Record B when time=0”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;基于这种版本机制，就不会出现另一个事务读取时，出现读到&lt;code class=&quot;highlighter-rouge&quot;&gt;Record C&lt;/code&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;Record B&lt;/code&gt;还未被&lt;code class=&quot;highlighter-rouge&quot;&gt;Transaction X&lt;/code&gt;更新的中间结果，因为其它事务所看到的系统依然处于Time=1的状态。&lt;/p&gt;

&lt;p&gt;至于说，每个事务应该看到具体什么版本的数据，这个是由不同系统的MVCC实现来决定的，下文我会介绍MySQL的MVCC实现。除了读到的数据必须小于等于当前系统已提交的版本外，写事务在提交时必须大于当前的版本，而这里如果想想还会有一个问题，如果Time=2的时刻，开启了多个写或更新事务，当它们同时尝试提交时，必然会有一个事务发现数据库已经处于Time=2的状态了，那么这个事务该怎么办了？大家可以好好想想。&lt;/p&gt;

&lt;h2 id=&quot;mysql的mvcc&quot;&gt;MySQL的MVCC&lt;/h2&gt;

&lt;p&gt;MySQL的Innodb引擎支持多种事务隔离级别，而其中的RR级别（Repeatable-Read）就是依靠MVCC来实现的，MySQL中MVCC的版本指的是事务ID（Transaction ID），首先来看一下MySQL Innodb中行记录的存储格式，除了最基本的行信息外，还会有一些额外的字段，这里主要介绍和MVCC有关的字段：&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_TRX_ID&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_ROLL_PTR&lt;/code&gt;，如下是一张表的初始信息：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Primary Key&lt;/th&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;DATA_TRX_ID&lt;/th&gt;
      &lt;th&gt;DATA_ROLL_PTR&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2018-4-28&lt;/td&gt;
      &lt;td&gt;Huan&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里面为了便于说明，表中&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_TRX_ID&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_ROLL_PTR&lt;/code&gt;存的值是Mock的值：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_TRX_ID&lt;/code&gt;：最近更新这条记录的Transaction ID，数据库每开启一个事务，事务ID都会增加，每个事务拿到的ID都不一样&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_ROLL_PTR&lt;/code&gt;：用来存储指向Undo Log中旧版本数据指针，支持了事务的回滚&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最开始的记录无法回滚，所以DATA_ROLL_PTR为空。&lt;/p&gt;

&lt;p&gt;这个时候开启事务A（事务ID:2），对记录进行了更新，但还没有提交，那么当前的数据为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/transaction_1.png&quot; alt=&quot;Transaction 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，旧的数据会被存到Undo Log中，通过当前记录中的&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_ROLL_PTR&lt;/code&gt;关联，那么如果另一个事务中想读取该数据，读到的会是什么数据了？假如说另一个事务B在事务A之后开启(事务ID:3)，既然我们最开始说Innodb的MVCC是基于事务ID做的，那么既然事务B的事务ID比事务A的大，那么事务B就可以独到A还未提交的数据了，这明显和Innodb RR的定义不符合。实际上，事务读取时，判断应该读取哪个版本的记录，有一个较为复杂的逻辑，不是单纯的和记录上的事务ID进行比较，假设当前读的事务ID为read&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;，记录当前存储的事务ID为&lt;code class=&quot;highlighter-rouge&quot;&gt;tid&lt;/code&gt;，当前系统中未提交的事务中的最大最小事务ID分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;max_tid&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;min_tid&lt;/code&gt;，那么数据可见性判断流程为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/transaction_visibility.png&quot; alt=&quot;Transaction visibility&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上图（这个图是通过分析网上的一些博客内容得到的，和实际MySQL的逻辑细节可能不一致），在来分析上文提到的Case，由于事务B的事务ID不满足&lt;code class=&quot;highlighter-rouge&quot;&gt;read_id=tid||tid&amp;lt;min_tid&lt;/code&gt;的条件，且该记录当前有&lt;code class=&quot;highlighter-rouge&quot;&gt;DATA_ROLL_PTR&lt;/code&gt;，所以最后该事务B实际读取的是Undo Log中的记录：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Primary Key&lt;/th&gt;
      &lt;th&gt;Time&lt;/th&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;DATA_TRX_ID&lt;/th&gt;
      &lt;th&gt;DATA_ROLL_PTR&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2018-4-28&lt;/td&gt;
      &lt;td&gt;Huan&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;需要注意的是，MySQL的MVCC和理论上的MVCC实际有所差异，MySQL同一时刻只允许一个事务去操作某条数据，该条数据上的操作实际是串行的，也就是说一条记录的有用版本&lt;code class=&quot;highlighter-rouge&quot;&gt;实际就只会有当前记录和一条Undo Log记录&lt;/code&gt;，是&lt;code class=&quot;highlighter-rouge&quot;&gt;悲观锁&lt;/code&gt;的操作方式，而MVCC的定义上实际是&lt;code class=&quot;highlighter-rouge&quot;&gt;乐观锁&lt;/code&gt;的操作方式，某一时刻记录可以存在很多个版本。&lt;/p&gt;

</description>
        <pubDate>Tue, 01 May 2018 14:26:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/mysql/2018/05/01/MVCC.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/mysql/2018/05/01/MVCC.html</guid>
        
        
        <category>MySQL</category>
        
      </item>
    
      <item>
        <title>MySQL 5.7 insert on duplicate key问题</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#背景&quot; id=&quot;markdown-toc-背景&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#原因分析&quot; id=&quot;markdown-toc-原因分析&quot;&gt;原因分析&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#数据表和例子&quot; id=&quot;markdown-toc-数据表和例子&quot;&gt;数据表和例子&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#原因分析-1&quot; id=&quot;markdown-toc-原因分析-1&quot;&gt;原因分析&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;参考链接：&lt;a href=&quot;https://bugs.mysql.com/bug.php?id=52020&quot;&gt;InnoDB can still deadlock on just INSERT…ON DUPLICATE KEY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在对不同的记录进行&lt;code class=&quot;highlighter-rouge&quot;&gt;INSERT...ON DUPLICATE KEY&lt;/code&gt;操作时，理论上是不会存在死锁问题的，但在5.7.18等版本中，该操作却可能导致死锁，这篇文章主要分析产生的原因。&lt;/p&gt;

&lt;h2 id=&quot;原因分析&quot;&gt;原因分析&lt;/h2&gt;

&lt;h3 id=&quot;数据表和例子&quot;&gt;数据表和例子&lt;/h3&gt;

&lt;p&gt;假如数据表&lt;code class=&quot;highlighter-rouge&quot;&gt;Test&lt;/code&gt;的结构如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Id&lt;/th&gt;
      &lt;th&gt;Uniq&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;Id&lt;/code&gt;为主键，&lt;code class=&quot;highlighter-rouge&quot;&gt;Uniq&lt;/code&gt;为唯一索引，执行如下操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Transaction 1:
start transaction;
insert into Test values(3,3) on duplicate key update id=3,uniq=3;

Transaction 2:
start transaction;
insert into Test values(4,4) on duplicate key update id=4,uniq=4;

Transaction 3:
start transaction;
insert into Test values(5,5) on duplicate key update id=5,uniq=5;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;原因分析-1&quot;&gt;原因分析&lt;/h3&gt;

&lt;p&gt;理论上这三条记录的主键值和唯一索引值都不一样，他们插入的时候都会获取&lt;code class=&quot;highlighter-rouge&quot;&gt;(2,6)&lt;/code&gt;区间的&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert Intention Lock&lt;/code&gt;，但由于各自插入的主键值和唯一索引没有冲突，所以实际是可以正常插入的的，不会发生思索。&lt;/p&gt;

&lt;p&gt;那么为什么MySQL的部分版本这种情况下会发生死锁了？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://bugs.mysql.com/bug.php?id=52020

This Bug#52020 (accidental re-introduction of Bug#7975 in MySQL 5.1) affects tables that do not contain a secondary index.

There is another bug that affects tables with secondary indexes:

Bug#50413 insert on duplicate key update sometimes writes binlog position incorrectly

Despite the title, Bug#50413 can occur even if MySQL replication or binlog is not used. That bug has was fixed in MySQL 5.7.4. 
The fix is that when we encounter a duplicate key in the clustered index or in any unique secondary index during an INSERT, 

we will acquire gap locks in the not-yet-checked secondary indexes as well. In this way, the INSERT will already have acquired some locks for the ON DUPLICATE KEY UPDATE part,

thus avoiding some potential deadlocks.

When there are multiple unique indexes, the execution of ON DUPLICATE KEY UPDATE can be ambiguous, which makes it tricky for statement-based replication.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意上面叙述中的关键一条：&lt;code class=&quot;highlighter-rouge&quot;&gt;Despite the title, Bug#50413 can occur even if MySQL replication or binlog is not used. That bug has was fixed in MySQL 5.7.4. The fix is that when we encounter a duplicate key in the clustered index or in any unique secondary index during an INSERT&lt;/code&gt;，开发者为了解决一个Bug，在&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt;数据时，除了给主键加&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert Intention Lock&lt;/code&gt;，还会给唯一索引加&lt;code class=&quot;highlighter-rouge&quot;&gt;Gap Lock&lt;/code&gt;，但这就带来了这篇文章描述的问题。&lt;/p&gt;

&lt;p&gt;当我们上文的三个事务插入时，他们除了都想在&lt;code class=&quot;highlighter-rouge&quot;&gt;(2,6)&lt;/code&gt;区间加&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert Intention Lock&lt;/code&gt;之外，还想在&lt;code class=&quot;highlighter-rouge&quot;&gt;(2,6)&lt;/code&gt;区间上加&lt;code class=&quot;highlighter-rouge&quot;&gt;Gap Lock&lt;/code&gt;，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert Intention Lock&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Gap Lock&lt;/code&gt;冲突，这才导致了死锁。&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Apr 2018 23:15:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/mysql/2018/04/15/MySQL5.7%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/mysql/2018/04/15/MySQL5.7%E9%97%AE%E9%A2%98.html</guid>
        
        
        <category>MySQL</category>
        
      </item>
    
      <item>
        <title>会计入门小结</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#引言&quot; id=&quot;markdown-toc-引言&quot;&gt;引言&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#会计是干什么的&quot; id=&quot;markdown-toc-会计是干什么的&quot;&gt;会计是干什么的？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#会计三大报表&quot; id=&quot;markdown-toc-会计三大报表&quot;&gt;会计三大报表&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#资产负债表&quot; id=&quot;markdown-toc-资产负债表&quot;&gt;资产负债表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#利润表&quot; id=&quot;markdown-toc-利润表&quot;&gt;利润表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#现金流表&quot; id=&quot;markdown-toc-现金流表&quot;&gt;现金流表&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#柠檬汁摊范例&quot; id=&quot;markdown-toc-柠檬汁摊范例&quot;&gt;柠檬汁摊范例&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#第一周&quot; id=&quot;markdown-toc-第一周&quot;&gt;第一周&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#期初&quot; id=&quot;markdown-toc-期初&quot;&gt;期初&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#期中&quot; id=&quot;markdown-toc-期中&quot;&gt;期中&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#期末&quot; id=&quot;markdown-toc-期末&quot;&gt;期末&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#第二周&quot; id=&quot;markdown-toc-第二周&quot;&gt;第二周&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#期初-1&quot; id=&quot;markdown-toc-期初-1&quot;&gt;期初&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#期中-1&quot; id=&quot;markdown-toc-期中-1&quot;&gt;期中&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#期末-1&quot; id=&quot;markdown-toc-期末-1&quot;&gt;期末&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;引言&quot;&gt;引言&lt;/h1&gt;
&lt;p&gt;因为工作相关，所以最近开始了解会计相关的知识，最开始找了一本叫《基础会计学》的书，实际上是大学的教材，但这书实在太抽象了。为了能更好的理解（主要是一般在地铁上看书，地铁上看这种死扣概念的教材叫一个蛋疼），又试了试别的，最后找到这本&lt;a href=&quot;https://item.jd.com/11339593.html&quot;&gt;《世界上最简单的会计书》&lt;/a&gt;，一共才200页，真心是最简单的会计入门书，强烈推荐。&lt;/p&gt;

&lt;h1 id=&quot;会计是干什么的&quot;&gt;会计是干什么的？&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;会计是企业计量，核算财务经营成果的一种方法，是以货币为主要计量单位，以凭证为依据，借助于专门的技术方法对各单位的经营互动进行完整，联系，系统的反映和监督，借以加强经济管理，提高经济效益，同时是一切商业，经济活动的语言，准则和根据。它既是经济管理的重要组成部分，又是经济管理的重要工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段话是不是很长？我的理解是：会计是计量和管理企业经营行为的工具。&lt;/p&gt;

&lt;h1 id=&quot;会计三大报表&quot;&gt;会计三大报表&lt;/h1&gt;
&lt;p&gt;会计实际上是通过多种报表的编写来实现，这里面有三个很重要的报表：资产负债表，利润表，现金流表&lt;/p&gt;

&lt;h2 id=&quot;资产负债表&quot;&gt;资产负债表&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;资产负债表的编制目的就是在人和物中建立一种联系，它表明了你生意中所拥有的东西，以及这种东西与那些拥有它的人或对此有要求权的人们之间的关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;会计是以货币为单位来计量的，我们最关心也就是货币有多少，以及货币的归属了，资产负债表也就是起这么一个作用。下面是一个典型的资产负债表的截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/assetTable.png&quot; alt=&quot;资产负债表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左侧的资产是公司目前所有的所有现金，存活等物品或权益，而右边包含了负债和所有者权益，负债是需要偿还的债务，而所有者权益是公司占有的权益。一个最重要的公式是：&lt;code class=&quot;highlighter-rouge&quot;&gt;总资产=总负载及所有者权益&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;利润表&quot;&gt;利润表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/profitTable.png&quot; alt=&quot;利润表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;资产负债表记录了某一时刻你所拥有的资产，以及资产与人之间的关系。但是资产负债表并没有体现出实际的经营情况，比如说购买存货，生产商品，销售产品等，因此，为了满足这个需求，上图中的的利润表产生了。&lt;/p&gt;

&lt;p&gt;利润表中有几个概念：&lt;code class=&quot;highlighter-rouge&quot;&gt;销售收入&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;商品销售成本&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;毛利&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;费用&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;净利润&lt;/code&gt;，它们之间的关系是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;毛利=销售收入-商品销售成本&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;净利润=毛利-费用&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;商品销售成本&lt;/code&gt;是指的与产品生产过程中有关的所有支出，而&lt;code class=&quot;highlighter-rouge&quot;&gt;费用&lt;/code&gt;囊括的是企业经营中与产品生产不直接相关的其他支出。&lt;/p&gt;

&lt;h2 id=&quot;现金流表&quot;&gt;现金流表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/cast_flow.png&quot; alt=&quot;现金流表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现金流表记录的是现金的流入和流出，之所以把现金流单做一张表，是因为企业的经营实际上最重要的就是现金流。可能有人会问，经营靠利润表不就行了吗？但实际上利润是有欺骗性的，比如其对应的应收账款你就不一定真能收回来。&lt;/p&gt;

&lt;h1 id=&quot;柠檬汁摊范例&quot;&gt;柠檬汁摊范例&lt;/h1&gt;
&lt;p&gt;运用书中的案例，一个小男孩开了一个柠檬汁摊，并运用会计的知识来管理他的账务，这里我们记两周的例子来进行说明。之后的记录中商品的价格读者不要介意，只是为了方便而已。&lt;/p&gt;

&lt;h2 id=&quot;第一周&quot;&gt;第一周&lt;/h2&gt;

&lt;h3 id=&quot;期初&quot;&gt;期初&lt;/h3&gt;
&lt;p&gt;第一周小男孩拿出了自己的50元，并找父母借了100元，这是柠檬汁摊最初的状态，我们用期初负债表来记录。
&lt;img src=&quot;/HuangHuanBlog/pics/weak1_pre_debt.png&quot; alt=&quot;第一周期初资产负债表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个没什么可讲的，一开始都很简单，需要注意的是借款在表中体现的为&lt;code class=&quot;highlighter-rouge&quot;&gt;应付票据&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;期中&quot;&gt;期中&lt;/h3&gt;
&lt;p&gt;在这一周小男孩依次做了以下的事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;去杂货铺中买了50个柠檬（每个1块钱），5磅白糖（每磅2块钱），总计&lt;code class=&quot;highlighter-rouge&quot;&gt;60&lt;/code&gt;块钱&lt;/li&gt;
  &lt;li&gt;把买来的材料做成了60杯柠檬汁，用家里的杯子装着，每一杯柠檬汁的成本是&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;块钱&lt;/li&gt;
  &lt;li&gt;找来家里的小推车，把这60杯柠檬汁推出去卖，每一杯的价格是3块钱，最后成功卖出了&lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;杯&lt;/li&gt;
  &lt;li&gt;看见卖柠檬汁很挣钱，可恶的父母向你收取了&lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;块的杯子使用费和水费&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;期末&quot;&gt;期末&lt;/h3&gt;
&lt;p&gt;到了第一周末，我们这样记录这一周的资产负债中变化的项目：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;现金：&lt;/strong&gt; 一开始有150块的现金，买原材料用了60块钱，埋了50杯收入150元，给父母上缴了20元，所以最后是&lt;code class=&quot;highlighter-rouge&quot;&gt;150-60+150-20=220&lt;/code&gt;，其实现金流表也就做了这件事情&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;存货：&lt;/strong&gt; 每一杯柠檬汁的成本是1块钱，剩下10杯，所以存货是&lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;块钱&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本周盈利:&lt;/strong&gt; 这里的盈利简单来讲就是&lt;code class=&quot;highlighter-rouge&quot;&gt;收入-花费&lt;/code&gt;，更详细的计算会在利润表中体现，所以盈利是&lt;code class=&quot;highlighter-rouge&quot;&gt;150-50*1-20=80&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;那么第一周的期末负债表如下：&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/weak1_aft_debt.png&quot; alt=&quot;第一周期末资产负债表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然左右相等，那就说明妥妥的没问题了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;刚才算期末资产负债表的过程其实也做了现金流表和利润表的计算过程，只是没有在负债表中体现出来，下面我们先记录这一期的利润表：&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/week1_profit.png&quot; alt=&quot;第一周利润表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到利润表算出来的结果和资产负债表中的本周盈利是一致的，只是它更清晰的体现了&lt;code class=&quot;highlighter-rouge&quot;&gt;销售收入&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;商品成本&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;毛利&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;费用&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;净利润&lt;/code&gt;的值和组成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一周的现金流表如下：&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/week1_cash.png&quot; alt=&quot;第一周现金流表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很简单不是吗，现金流表更好的体现了现金的收支过程，最后和资产负债表中的现金相对应。&lt;/p&gt;

&lt;h2 id=&quot;第二周&quot;&gt;第二周&lt;/h2&gt;

&lt;h3 id=&quot;期初-1&quot;&gt;期初&lt;/h3&gt;
&lt;p&gt;有了第一周的成功，小男孩挣到了钱有了经验，但不幸的是冰箱里剩下的10杯柠檬汁杯爸妈和姐姐喝掉了，他们并不准备为此支付任何钱，于是期初的资产负债表变成了这样。
&lt;img src=&quot;/HuangHuanBlog/pics/week2_pre_debt.png&quot; alt=&quot;第二周期初资产负债表&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;期中-1&quot;&gt;期中&lt;/h3&gt;
&lt;p&gt;在这一周中小男孩依次做了以下的事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在杂货铺中&lt;code class=&quot;highlighter-rouge&quot;&gt;赊账&lt;/code&gt;购买了100个柠檬（每个1块钱），10磅白糖（每磅2块钱），总计&lt;code class=&quot;highlighter-rouge&quot;&gt;120&lt;/code&gt;块钱&lt;/li&gt;
  &lt;li&gt;把买来的材料做成了90杯柠檬汁，耗费了74个柠檬和磅糖，8磅白糖，每一杯成本&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;块钱&lt;/li&gt;
  &lt;li&gt;购买了一个二手的贩卖小车，花费了&lt;code class=&quot;highlighter-rouge&quot;&gt;150&lt;/code&gt;元&lt;/li&gt;
  &lt;li&gt;卖出了80杯柠檬汁，期中20杯是顾客赊购的，每一杯&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;块钱，销售额&lt;code class=&quot;highlighter-rouge&quot;&gt;240&lt;/code&gt;元，现金收入&lt;code class=&quot;highlighter-rouge&quot;&gt;180&lt;/code&gt;元&lt;/li&gt;
  &lt;li&gt;偿还了爸妈&lt;code class=&quot;highlighter-rouge&quot;&gt;50&lt;/code&gt;块钱，可恶的他们还收取了&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;块的利息&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;期末-1&quot;&gt;期末&lt;/h3&gt;
&lt;p&gt;这一周增加了几个新的项目：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;应付账款：&lt;/strong&gt; 因为在杂货铺中赊购了120元的东西，所以应付账款是&lt;code class=&quot;highlighter-rouge&quot;&gt;120&lt;/code&gt;元&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;固定资产：&lt;/strong&gt; 购买的贩卖小车是一项固定资产，计入资产列中，实际上是资产中&lt;code class=&quot;highlighter-rouge&quot;&gt;150&lt;/code&gt;元的现金转换成了固定资产，并不影响利润&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;应收账款：&lt;/strong&gt; 有20杯是顾客赊购的，这些要归于资产中的应付账款中，一共&lt;code class=&quot;highlighter-rouge&quot;&gt;60&lt;/code&gt;元&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;坏账:&lt;/strong&gt; 因为之前的10杯柠檬汁被强行消费掉了，其价值&lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;元只能算作亏损或者坏账去掉&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;那么第二周末的资产负债表如下：&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/week2_aft_debt.png&quot; alt=&quot;第二周末资产负债表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二周的利润表如下：&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/week2_profit.png&quot; alt=&quot;第二周利润表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和本期盈利是对应的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二周的现金流表如下:&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/week2_cash.png&quot; alt=&quot;第二周现金流量表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和资产负债表中的现金正好对应。&lt;/p&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;
&lt;p&gt;在我的理解中，资产负债表是一个宏观的记录表，二利润表和现金流表是其中关键项目的细化，通过这三个报表，能够较为清楚的了解到公司的经营状况。&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Jun 2017 23:07:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/read/2017/06/19/%E4%BC%9A%E8%AE%A1%E5%AD%A6%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/read/2017/06/19/%E4%BC%9A%E8%AE%A1%E5%AD%A6%E5%85%A5%E9%97%A8%E5%B0%8F%E7%BB%93.html</guid>
        
        
        <category>Read</category>
        
      </item>
    
      <item>
        <title>Innodb锁介绍-Innodb中死锁</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#死锁&quot; id=&quot;markdown-toc-死锁&quot;&gt;死锁&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#死锁的产生条件&quot; id=&quot;markdown-toc-死锁的产生条件&quot;&gt;死锁的产生条件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#死锁范例&quot; id=&quot;markdown-toc-死锁范例&quot;&gt;死锁范例&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#innodb中的死锁&quot; id=&quot;markdown-toc-innodb中的死锁&quot;&gt;Innodb中的死锁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#引言&quot; id=&quot;markdown-toc-引言&quot;&gt;引言&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#innodb死锁产生条件&quot; id=&quot;markdown-toc-innodb死锁产生条件&quot;&gt;Innodb死锁产生条件&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#innodb死锁范例&quot; id=&quot;markdown-toc-innodb死锁范例&quot;&gt;Innodb死锁范例&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#1-典型的死锁案例&quot; id=&quot;markdown-toc-1-典型的死锁案例&quot;&gt;1. 典型的死锁案例&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#2-insert死锁&quot; id=&quot;markdown-toc-2-insert死锁&quot;&gt;2. Insert死锁&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#3-工作中的另一个死锁case&quot; id=&quot;markdown-toc-3-工作中的另一个死锁case&quot;&gt;3. 工作中的另一个死锁Case&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;死锁&quot;&gt;死锁&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称之为死锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;死锁问题是计算机系统中常见的问题，在Innodb中同样存在。&lt;/p&gt;

&lt;h2 id=&quot;死锁的产生条件&quot;&gt;死锁的产生条件&lt;/h2&gt;
&lt;p&gt;死锁产生必须要满足以下四个条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;: 即为某个资源在同一时间只允许被一个单元占有。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不可抢占条件&lt;/strong&gt;:被单元占有的资源不可被其它单元抢占。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;占有且申请条件&lt;/strong&gt;:单元当前至少占有一个资源，且该单元同时向系统申请其它的资源。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;循环等待条件&lt;/strong&gt;:单元之前存在一个资源的循环等待序列。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;死锁范例&quot;&gt;死锁范例&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/deadlock.jpg&quot; alt=&quot;死锁&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在百度上盗了一张图，如图所示，单元T1和T2各自占有了一个资源，又同时想要占据别人的资源，这样僵持不下，也就产生了死锁。对于计算机系统而言，死锁会导致系统停滞，对于Innodb而言，死锁会给数据的读写产生阻碍。&lt;/p&gt;

&lt;h2 id=&quot;innodb中的死锁&quot;&gt;Innodb中的死锁&lt;/h2&gt;

&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;在介绍之前，先讲一个我们工作中踩到的一个坑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;背景描述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们的订单表中存在一个Unique Key，假设该Unique Key的名字为U_KEY，它是由一个ID和时间戳构成的。在实际运行中，存在用同一个Unique Key反复创建订单的行为，这种情况的发生有可能是因为恶意刷单或者是偶然的请求重发。对于这种情况，先到达的插入请求会成功，之后的请求会产生Unique Key冲突而失败，但这个过程中会时不时的出现Dead Lock Detected的情况(数据库会自动Kill死锁)，这里我们采用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;insert ignore&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在插入时，MySQL会给行记录加上排他锁(Index-record lock)，假如此时有三个同样的插入请求，都开启了事务，其中一个先拿到了排他锁开始插入，之后的事务会出现Duplicate Key错误，而此时它们会申请该行的共享锁，如果这个时候拿到排他锁的事务回滚，那么另外两个事务会同时申请该行的排他锁（过程参考&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/innodb-locks-set.html&quot;&gt;MySQL锁机制&lt;/a&gt;。由于排他锁和共享锁是互斥的，此时就产生了死锁的情况。&lt;/p&gt;

&lt;p&gt;这里可能会有人有疑问，为什么出现Duplicate Key错误的时候会加共享锁了，我的理解是冲突检测本身是一种读操作，所以冲突之后的轮询需要加共享锁。据这个例子的主要目的是告诉大家死锁问题是我们工作中会遇到的，需要重视。&lt;/p&gt;

&lt;h3 id=&quot;innodb死锁产生条件&quot;&gt;Innodb死锁产生条件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;两个以上的并发事务&lt;/li&gt;
  &lt;li&gt;每个事务当前持有了锁，且未释放&lt;/li&gt;
  &lt;li&gt;每个事务都在申请新的锁&lt;/li&gt;
  &lt;li&gt;事务之间产生了锁资源的循环等待&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实这也就是Innodb版的死锁条件，只是资源变成了锁而已。要避免死锁，其实就是要避免上诉死锁条件的产生，这种坑其实总会踩到了才会重视起来。&lt;/p&gt;

&lt;h3 id=&quot;innodb死锁范例&quot;&gt;Innodb死锁范例&lt;/h3&gt;

&lt;p&gt;明白了死锁的产生条件，那么我试着来实际测试一些典型的死锁情况。&lt;/p&gt;

&lt;h4 id=&quot;1-典型的死锁案例&quot;&gt;1. 典型的死锁案例&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;表的开始状态如下图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/trans_init.png&quot; alt=&quot;初始状态&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开启事务A，更新id=5的记录&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/trans_a_5.png&quot; alt=&quot;A 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开启事务B，更新id=6的记录&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/trans_b_6.png&quot; alt=&quot;B 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开启事务A，更新id=6的记录，会发现卡住了&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/trans_a_6.png&quot; alt=&quot;A 6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;再在事务B，更新id=5的记录，会发现出现了死锁&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/trans_b_5.png&quot; alt=&quot;B 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后事务A更新id=6的记录执行成功，因为事务B因为死锁被数据库Kill掉了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/trans_5_commit.png&quot; alt=&quot;A commit&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-insert死锁&quot;&gt;2. Insert死锁&lt;/h4&gt;
&lt;p&gt;在引言中我介绍了一个我们工作中遇到的坑，下面我们尝试自己复现一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表的开始状态如下图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/insert_init.png&quot; alt=&quot;初始状态&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务A插入一条id=7的记录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/insert_a_insert.png&quot; alt=&quot;A insert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务B执行同样的插入语句&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/insert_other_insert.png&quot; alt=&quot;Other insert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会发现事务卡住了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务C执行同样的插入语句&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/insert_other_insert.png&quot; alt=&quot;Other insert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现事务同样卡住了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务A rollback&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/insert_a_rollback.png&quot; alt=&quot;A rollback&quot; /&gt;&lt;/p&gt;

&lt;p&gt;事务A &lt;code class=&quot;highlighter-rouge&quot;&gt;rollback&lt;/code&gt;后，会发现事务C爆出了 &lt;strong&gt;死锁&lt;/strong&gt; ,符合我们的设想&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/insert_c_deadlock.png&quot; alt=&quot;C deadlock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需要注意的是&lt;/strong&gt; ，如果事务A不是&lt;code class=&quot;highlighter-rouge&quot;&gt;rollback&lt;/code&gt;，而是&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，那么不会产生死锁，而是爆出两个Duplicate Error，读者可以想一下这是为什么？&lt;/p&gt;

&lt;h4 id=&quot;3-工作中的另一个死锁case&quot;&gt;3. 工作中的另一个死锁Case&lt;/h4&gt;

&lt;p&gt;这个Case产生的原因是，事务想要&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;一条记录，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;select for update&lt;/code&gt;该条记录，但如果针对一条记录，有三个事务并发执行，那么同样会产生死锁，死锁的原因其实和上面类似，都是因为在产生Duplicate Error时，事务会加Share lock。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表的开始状态如下图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/insert_init.png&quot; alt=&quot;初始状态&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务A如下图执行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/case_a_insert.png&quot; alt=&quot;Case a&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务B和C都执行语句如下&lt;/strong&gt;
&lt;strong&gt;事务B&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/case_bc_insert.png&quot; alt=&quot;Case b c&quot; /&gt;
&lt;strong&gt;事务C&lt;/strong&gt;
&lt;img src=&quot;/HuangHuanBlog/pics/case_bc_insert.png&quot; alt=&quot;Case b c&quot; /&gt;
会发现事务都卡住&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务A此时commit&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/case_a_commit.png&quot; alt=&quot;Case a commit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会发现事务B和C同时爆出Duplicate Key Error&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/case_bc_duplicate.png&quot; alt=&quot;Case b c Duplicate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务B和C执行Select for update&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这时事务B和C依次也执行&lt;code class=&quot;highlighter-rouge&quot;&gt;select for update&lt;/code&gt;，事务B会卡住，事务C会产生如下图的死锁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/case_bc_deadlock.png&quot; alt=&quot;Case b c deadlcok&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 30 May 2017 21:23:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/mysql/2017/05/30/Innodb%E6%AD%BB%E9%94%81.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/mysql/2017/05/30/Innodb%E6%AD%BB%E9%94%81.html</guid>
        
        
        <category>MySQL</category>
        
      </item>
    
      <item>
        <title>PHP自动化测试锤子-PHPUnit&amp;Uopz</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#php自动化测试概述&quot; id=&quot;markdown-toc-php自动化测试概述&quot;&gt;PHP自动化测试概述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#锤子一-phpunit&quot; id=&quot;markdown-toc-锤子一-phpunit&quot;&gt;锤子一: PHPUnit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#锤子二-uopz&quot; id=&quot;markdown-toc-锤子二-uopz&quot;&gt;锤子二: Uopz&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#锤子三jenkins&quot; id=&quot;markdown-toc-锤子三jenkins&quot;&gt;锤子三：Jenkins&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php自动化测试概述&quot;&gt;PHP自动化测试概述&lt;/h2&gt;
&lt;p&gt;PHP是一种偏脚本化的语言，了解过ES6的朋友会发现PHP和ES6其实语法和一些特性上已经很接近了，对于我这种一直学Java的人来讲，觉得PHP和ES6语法上基本没太大区别。由于PHP的这种脚本化的特性，编码的风格一个人一个样，令其难以进行测试，这应该是每个想对PHP搞自动化测试，特别是其中单元化测试的人都会遇到的问题。我最近在公司接了个任务，要对项目中的一些很复杂的回路脚本进行自动化测试，希望组内所有人Merge代码的时候，会自动跑测试Case，这篇文章就是分享我在做这个任务时所找到的锤子。&lt;/p&gt;

&lt;h2 id=&quot;锤子一-phpunit&quot;&gt;锤子一: PHPUnit&lt;/h2&gt;
&lt;p&gt;PHPUnit是大家马上就会找到的一个锤子，关于它官方提供了PHPUnit-Book，里面介绍了其提供的测试工具和一些测试基本理念，大家可以花一天左右的时间系统的看完这个文档，我这里就不做赘述了。我举一个 &lt;strong&gt;理想情况&lt;/strong&gt; 下的PHPUnit测试的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/phpunit-ideal.png&quot; alt=&quot;PHPUnit-ideal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图展示的是测试&lt;code class=&quot;highlighter-rouge&quot;&gt;MyFoo&lt;/code&gt;类中的&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething&lt;/code&gt;方法，这个方法实际是调用了传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;MyBar&lt;/code&gt;类中的&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomethingElse&lt;/code&gt;方法，在这种情况下，我们只需要利用PHPUnit提供的测试替身工具，构建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;MyBar&lt;/code&gt;的测试替身，然后Mock掉其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomethingElse&lt;/code&gt;方法，再将其传入&lt;code class=&quot;highlighter-rouge&quot;&gt;MyFoo&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething&lt;/code&gt;方法中。&lt;/p&gt;

&lt;p&gt;通过上面的步骤，我们实现了单元测试所需要的隔离，&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething&lt;/code&gt;方法不再实际依赖于外部。然后我们只需要对这个php文件执行&lt;code class=&quot;highlighter-rouge&quot;&gt;phpunit&lt;/code&gt;命令，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;前缀的方法就会被运行，一个测试就跑起来了。&lt;/p&gt;

&lt;p&gt;然而虽然理想是丰满的，但现实很残酷，实际的PHP代码很少有这么写的，且不说每个人各有各的风格，每个公司还各有个的框架，下面举个我们公司常见的写法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/phpunit-real.png&quot; alt=&quot;PHPUnit-real&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图上所示，我们的项目中倾向于这种静态调用的面向过程写法，这种写法的问题是PHPUnit基本上就失效了，我们的测试将无从入手，那么该怎么办了?&lt;/p&gt;

&lt;h2 id=&quot;锤子二-uopz&quot;&gt;锤子二: Uopz&lt;/h2&gt;
&lt;p&gt;PHPUnit无法解决问题，有两个工具可以解决 &lt;strong&gt;php-test-helper&lt;/strong&gt; 和 &lt;strong&gt;Uopz&lt;/strong&gt; ，其中 &lt;strong&gt;php-test-helper&lt;/strong&gt; 实际已经不再维护了，Github主页上也指向了 &lt;strong&gt;Uopz&lt;/strong&gt;，这里我也就主要说说 &lt;strong&gt;Uopz&lt;/strong&gt; 工具，这个工具可以做什么了，&lt;strong&gt;Uopz&lt;/strong&gt; 的全称是 &lt;strong&gt;User Operations For Zend&lt;/strong&gt; ，能够在运行时改变PHP的行为，下面是它提供的主要方法：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;&lt;span class=&quot;nb&quot;&gt;uopz_function&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//备份一个方法&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;uopz_compose&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//构建一个类&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;uopz_flags&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//改变类或者方法的Flag定义&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;uopz_function&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//创建一个function&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;uopz_overload&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//覆盖一个VM的操作码（这个后来并没有使用，存在问题，实际使用时通过PHPUnit的基境来实现了这个方法的功能）&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;uopz_redefine&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//创建或者重定义一个常量&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;uopz_restore&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//恢复方法到之前备份的状态&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这个工具十分强大，基于它真的什么都能搞，就是麻烦点，比如刚才哪个PHPUnit不可测的代码，用上Uopz就不一样了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/uopz.png&quot; alt=&quot;Uopz&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PHPUnit不能Mock静态的方法，但Uopz可以，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;uopz_function&lt;/code&gt;方法，可以改变原始的&lt;code class=&quot;highlighter-rouge&quot;&gt;MyBar1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;MyBar2&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;doSomething&lt;/code&gt;方法的行为，达到我们刚才用PHPUnit构造测试替身的效果。甚至你还可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;uopz_compose&lt;/code&gt;重定义一个自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;MyBar1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;MyBar2&lt;/code&gt;，有了这个方法几乎无所不能，但代价也就是麻烦点。&lt;/p&gt;

&lt;p&gt;我用这个给公司的回路脚本写测试Case，200行的回路代码，写了1000多行的测试代码，因为要Mock太多的类，重定义很多方法，确实很麻烦，对于经常改动的代码，这样搞代价可能不可承受，但如果代码的变动不大，但每次改动的风险却很大，那么这个就值得了。关于Uopz的详细用法，大家可以找我交流，里面坑还是不少。&lt;/p&gt;

&lt;h2 id=&quot;锤子三jenkins&quot;&gt;锤子三：Jenkins&lt;/h2&gt;
&lt;p&gt;对于自动化来讲，Jenkins应该是最常用的CI工具了，要做的也就是配置对仓库定期的变动检查，或者代码长裤自己挂Hook，通知Jenkins运行自测代码。这样每次代码变动时，Jenkins都会跑一遍Case，如果发现问题则可以邮件通知开发者。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;PHPUnit Uopz Jenkins&lt;/strong&gt; 是用的自动化测试三剑客，三者缺一不可，如果想更好的更高效的进行自动化测试，有两个建议：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;代码可测性（这其实是最重要的了）&lt;/li&gt;
  &lt;li&gt;封装Uopz的方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;做到这些，PHP的自动化测试将简单而高效。&lt;/p&gt;
</description>
        <pubDate>Sun, 14 May 2017 21:08:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/php/2017/05/14/PHP%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/php/2017/05/14/PHP%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95.html</guid>
        
        
        <category>PHP</category>
        
      </item>
    
      <item>
        <title>Innodb锁介绍-Innodb中的各类锁概述</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#innodb锁概述&quot; id=&quot;markdown-toc-innodb锁概述&quot;&gt;Innodb锁概述&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#概述&quot; id=&quot;markdown-toc-概述&quot;&gt;概述&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#一次封锁法&quot; id=&quot;markdown-toc-一次封锁法&quot;&gt;一次封锁法&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#两阶段锁协议&quot; id=&quot;markdown-toc-两阶段锁协议&quot;&gt;两阶段锁协议&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#加锁阶段&quot; id=&quot;markdown-toc-加锁阶段&quot;&gt;加锁阶段&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#解锁阶段&quot; id=&quot;markdown-toc-解锁阶段&quot;&gt;解锁阶段&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#innodb中的各种锁&quot; id=&quot;markdown-toc-innodb中的各种锁&quot;&gt;Innodb中的各种锁&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#shared-lock-and-exclusive-locks&quot; id=&quot;markdown-toc-shared-lock-and-exclusive-locks&quot;&gt;Shared Lock And Exclusive Locks&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#record-locks&quot; id=&quot;markdown-toc-record-locks&quot;&gt;Record Locks&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#next-key-locks&quot; id=&quot;markdown-toc-next-key-locks&quot;&gt;Next-key Locks&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#intention-locks&quot; id=&quot;markdown-toc-intention-locks&quot;&gt;Intention Locks&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#gap-locks&quot; id=&quot;markdown-toc-gap-locks&quot;&gt;GAP Locks&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#insert-intention-locks&quot; id=&quot;markdown-toc-insert-intention-locks&quot;&gt;Insert Intention Locks&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#auto-inc-locks&quot; id=&quot;markdown-toc-auto-inc-locks&quot;&gt;AUTO-INC Locks&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;innodb锁概述&quot;&gt;Innodb锁概述&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;参考文档:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://tech.meituan.com/innodb-lock.html&quot;&gt;美团Innodb锁介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://yeshaoting.cn/article/database/mysql%20insert%E9%94%81%E6%9C%BA%E5%88%B6/&quot;&gt;MySQL insert锁机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html&quot;&gt;MySQL锁官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Innodb中行级锁作用于索引之上，如果没有索引，则只能够锁表。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;一次封锁法&quot;&gt;一次封锁法&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;为了预防死锁，一般应用中推荐一次封锁法。也就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行完成之后，再进行解锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一次封锁法能够预防死锁，但从该方法的定义中可以看到，每次操作都锁住全部数据，如果这样数据的执行只能是串行化的，性能不高。&lt;/p&gt;

&lt;h3 id=&quot;两阶段锁协议&quot;&gt;两阶段锁协议&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;数据库遵循的是两段锁协议，将事物分解成加锁和解锁两个阶段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;加锁阶段&quot;&gt;加锁阶段&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;该阶段可以进行加锁操作，在对任何数据进行读操作之前要申请并获得S锁(Shared Lock，其它事务可以继续加S锁，但不能加Exclusive Lock，即排他锁)；而在进行写操作之前，需要申请X锁(Exclusive Lock，其它事务不能再获得任何锁)。加锁不成功则进入等待状态，而不能再加其它锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从这个定义可以看出，加锁阶段定义了事务之间的协调规则，能够有效提高多个事务之间的执行性能，但同时也带来了死锁的风险，之后会举例介绍死锁的成因。&lt;/p&gt;

&lt;h4 id=&quot;解锁阶段&quot;&gt;解锁阶段&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;事务进入解锁阶段将释放其持有的锁，该阶段只能进行解锁操作，而不能再加其它锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;innodb中的各种锁&quot;&gt;Innodb中的各种锁&lt;/h2&gt;

&lt;h3 id=&quot;shared-lock-and-exclusive-locks&quot;&gt;Shared Lock And Exclusive Locks&lt;/h3&gt;

&lt;p&gt;这是两个行级锁，包括 &lt;strong&gt;Shared Lock(S 共享锁)&lt;/strong&gt; 和 &lt;strong&gt;Exclusive Lock(X 排他锁):&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;共享锁&lt;/strong&gt; 允许持有锁的事务去读取一行数据，可以有多个事务同时持有共享锁，但当数据被加上共享锁时，不能再被加排他锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;排他锁&lt;/strong&gt; 允许持有锁的事务去更新或则删除一行数据，同时只能有一个事务持有排他锁，当数据被加上排他锁时，不能再加共享锁。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;record-locks&quot;&gt;Record Locks&lt;/h3&gt;

&lt;p&gt;记录锁是作用在索引上，比如这么一条语句：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPDATE&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这条语句将会在&lt;code class=&quot;highlighter-rouge&quot;&gt;c1&lt;/code&gt;值为10这条记录的索引加锁，阻止其它事务的插入，更新和删除操作。
即使&lt;code class=&quot;highlighter-rouge&quot;&gt;c1&lt;/code&gt;不存在索引，Innodb也会创建一个隐藏的&lt;code class=&quot;highlighter-rouge&quot;&gt;clustered index&lt;/code&gt;，并用其作为锁的依据。&lt;/p&gt;

&lt;h3 id=&quot;next-key-locks&quot;&gt;Next-key Locks&lt;/h3&gt;

&lt;p&gt;Next-key锁是记录锁和Gap锁的结合，锁住了记录和记录之前的一段Gap区间。
比如索引包含了10，11，13和20，那么Next-key分出的区间如下：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;negative&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infinity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positive&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infinity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;intention-locks&quot;&gt;Intention Locks&lt;/h3&gt;

&lt;p&gt;Intention Locks(意向锁)是MySQL为了支持不同粒度的锁而设计的一种 &lt;strong&gt;表级别锁(但不是通常认为的表锁)&lt;/strong&gt; ，它表示了表之后将被加上哪种行级锁。意向锁的分类如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Intention Shared Lock，意向共享锁(IS)&lt;/strong&gt; ，表示事务将要在表上加共享锁，规则是在表中申请某些行的共享锁之前，必须先申请&lt;code class=&quot;highlighter-rouge&quot;&gt;IS&lt;/code&gt;锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Intention Exclusive Lock，意向排他锁(IX)&lt;/strong&gt; ，表示事务将要在表上加排他锁，规则是在表中申请某些行的排他锁之前，必须先申请&lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt;锁。&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SHARE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MODE&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;该语句将会在表上加&lt;code class=&quot;highlighter-rouge&quot;&gt;IS&lt;/code&gt;锁，同时在对应的记录上加上&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;锁。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FOR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UPDATE&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;该语句将会在表上加上&lt;code class=&quot;highlighter-rouge&quot;&gt;IX&lt;/code&gt;锁，同时在对应的记录上加上&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;表级锁的兼容性矩阵：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/matrix.png&quot; alt=&quot;Matrix&quot; /&gt;&lt;/p&gt;

&lt;p&gt;事实上意向锁不会和行级的&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;锁产生冲突，只会和表级的&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;锁产生冲突。&lt;/p&gt;

&lt;h3 id=&quot;gap-locks&quot;&gt;GAP Locks&lt;/h3&gt;
&lt;p&gt;Gap锁是一种范围锁，Gap锁作用范围是Record锁之间，或者Record锁之前与Record锁之后的范围。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/HuangHuanBlog/pics/gap.png&quot; alt=&quot;Gap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，首先当前该记录存在索引，id为5和30的记录将整个分为了 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;5&lt;/code&gt; ，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;5&amp;amp;&amp;lt;30&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;30&lt;/code&gt; 三个区间，如果要更新30的数据，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;5&lt;/code&gt; 的所有区间都会被锁住。&lt;/p&gt;

&lt;h3 id=&quot;insert-intention-locks&quot;&gt;Insert Intention Locks&lt;/h3&gt;
&lt;p&gt;Insert Intention Locks也就是插入意向锁，但它其实是一种GAP锁，在行数据被插入之前，设定的一种锁，如果两个事务要插入同一个GAP中的不同行记录，它们都会获取这个GAP的插入意向锁，但相互之间不会冲突。&lt;/p&gt;

&lt;h3 id=&quot;auto-inc-locks&quot;&gt;AUTO-INC Locks&lt;/h3&gt;
&lt;p&gt;AUTO-INC锁是一种特殊的表级别锁，主要处理表中带有自增列的情况。实际上是为了保证自增的正确性，所以有了这种锁。&lt;/p&gt;
</description>
        <pubDate>Sun, 07 May 2017 17:05:00 +0800</pubDate>
        <link>http://localhost:4000/HuangHuanBlog/mysql/2017/05/07/Innodb%E9%94%81.html</link>
        <guid isPermaLink="true">http://localhost:4000/HuangHuanBlog/mysql/2017/05/07/Innodb%E9%94%81.html</guid>
        
        
        <category>MySQL</category>
        
      </item>
    
  </channel>
</rss>
