I"¶<ul id="markdown-toc">
  <li><a href="#ç®—æ³•å¯¼è®ºå­¦ä¹ " id="markdown-toc-ç®—æ³•å¯¼è®ºå­¦ä¹ ">ç®—æ³•å¯¼è®ºå­¦ä¹ </a></li>
  <li><a href="#ç®—æ³•åŸºç¡€" id="markdown-toc-ç®—æ³•åŸºç¡€">ç®—æ³•åŸºç¡€</a>    <ul>
      <li><a href="#æ’å…¥æ’åº" id="markdown-toc-æ’å…¥æ’åº">æ’å…¥æ’åº</a></li>
    </ul>
  </li>
  <li><a href="#åˆ†æ²»ç­–ç•¥" id="markdown-toc-åˆ†æ²»ç­–ç•¥">åˆ†æ²»ç­–ç•¥</a>    <ul>
      <li><a href="#æœ€å¤§è¿ç»­å­æ•°ç»„å’Œ" id="markdown-toc-æœ€å¤§è¿ç»­å­æ•°ç»„å’Œ">æœ€å¤§è¿ç»­å­æ•°ç»„å’Œ</a></li>
    </ul>
  </li>
</ul>

<h2 id="ç®—æ³•å¯¼è®ºå­¦ä¹ ">ç®—æ³•å¯¼è®ºå­¦ä¹ </h2>

<blockquote>
  <p>ä¹‹å‰çš„ç®—æ³•å­¦ä¹ æ›´å¤šçš„æ˜¯ä¸ºé¢è¯•å‡†å¤‡ï¼Œå…·æœ‰å¾ˆå¼ºçš„ç›®çš„æ€§ã€‚ç°åœ¨çš„å‡ºå‘ç‚¹æ˜¯è¿›ä¸€æ­¥ç†è§£å’ŒæŒæ¡åŸºæœ¬çš„ç®—æ³•ï¼Œå¹¶é™ä¸‹å¿ƒæ¥é¢†ä¼šç®—æ³•ä¸­æ€è€ƒå’Œè§£å†³é—®é¢˜çš„æ–¹å¼ï¼Œä¹¦ä¸­å¤æ‚åº¦éƒ¨åˆ†çš„å­¦ä¹ æš‚æ—¶ç•¥è¿‡ã€‚</p>
</blockquote>

<p>ä¸»è¦å­¦ä¹ èµ„æ–™ï¼š<a href="http://open.163.com/special/opencourse/algorithms.html">ç®—æ³•å¯¼è®º ç¬¬ä¸‰ç‰ˆ</a></p>

<p>ä»£ç åœ°å€ï¼š<a href="https://github.com/sadwxqezc/Algorithms.git">Github</a></p>

<h2 id="ç®—æ³•åŸºç¡€">ç®—æ³•åŸºç¡€</h2>

<blockquote>
  <p>ç®—æ³•æ˜¯è§£å†³é—®é¢˜çš„æ­¥éª¤</p>
</blockquote>

<h3 id="æ’å…¥æ’åº">æ’å…¥æ’åº</h3>

<p>ã€Šç®—æ³•å¯¼è®ºã€‹ä¸­å¯¹æ’å…¥æ’åºä¸¾äº†ä¸€ä¸ªéå¸¸æ°å½“çš„åˆ—å­ï¼šå¤§å®¶æ–—åœ°ä¸»æ—¶ï¼Œè¾¹æ‘¸ç‰Œè¾¹å¯¹æ‰‹ä¸­çš„ç‰Œæ’åºï¼Œè¿™å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªæ’å…¥æ’åºçš„è¿‡ç¨‹ï¼Œä¿è¯æ‰‹ä¸­çš„ç‰Œå§‹ç»ˆæ˜¯æœ‰åºçš„ã€‚</p>

<p>å°†å¦‚æˆ‘ä»¬è¦å¯¹æ•°ç»„<code class="language-plaintext highlighter-rouge">[1,3,7,-1,11,2,23,0,1]</code>æ’åºï¼Œè¦æ±‚ç»“æœä¸ºå‡åºï¼Œç”¨æ’å…¥æ’åºçš„å†™æ³•å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void myInsertSort(int[] sequence) {
    for (int j = 1; j &lt; sequence.length; j++) {
        int i = 0;
        int temp = sequence[j];
        while (i &lt; j &amp;&amp; sequence[i] &lt; temp) {
            i++;
        }
        for (int k = j; k &gt; i; k--) {
            sequence[k] = sequence[k - 1];
        }
        sequence[i] = temp;
    }
}
</code></pre></div></div>

<p>æˆ‘çš„åšæ³•æ˜¯ä»å‰å¾€åæ‰¾æ’å…¥ä½ç½®ï¼Œè€Œä¹¦ä¸­çš„åšæ³•æ˜¯ä»åå¾€å‰æ‰¾ï¼Œå…¶å†™æ³•å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void bookInsertSort(int[] sequence) {
    for (int j = 1; j &lt; sequence.length; j++) {
        int temp = sequence[j];
        int i = j - 1;
        while (i &gt; 0 &amp;&amp; sequence[i] &gt; temp) {
            sequence[i + 1] = sequence[i];
            i--;
        }
        sequence[i + 1] = temp;
    }
}
</code></pre></div></div>

<p>ä¸¤è€…æ—¶é—´æ€§èƒ½å·®åˆ«ä¸å¤§ï¼Œä¹¦ä¸Šçš„å†™æ³•æ˜¾å¾—æ›´åŠ ç®€æ´ã€‚</p>

<h2 id="åˆ†æ²»ç­–ç•¥">åˆ†æ²»ç­–ç•¥</h2>

<p>åˆ†æ²»ç­–ç•¥(Divide and Conquer)å¯»æ±‚çš„æ˜¯é€’å½’çš„æ±‚è§£å­é—®é¢˜ï¼ŒæŠŠè§„æ¨¡å¤§çš„é—®é¢˜åˆ†è§£æˆè§„æ¨¡æ›´å°çš„é—®é¢˜å»è§£å†³ï¼Œåœ¨æ¯ä¸ªé€’å½’ä¸­æœ‰å¦‚ä¸‹ä¸‰ä¸ªæ­¥éª¤ï¼š</p>

<ul>
  <li>åˆ†è§£(Divide)ï¼šå°†é—®é¢˜åˆ’åˆ†ä¸ºè§„æ¨¡æ›´å°çš„å­é—®é¢˜ï¼Œé—®é¢˜çš„æœ¬è´¨ä¸åŸé—®é¢˜ä¸€è‡´</li>
  <li>è§£å†³(Conquer)ï¼šé€’å½’çš„æ±‚è§£å‡ºå­é—®é¢˜ï¼Œå¦‚æœå­é—®é¢˜çš„è§„æ¨¡å·²ç»è¶³å¤Ÿå°ï¼Œåˆ™åœæ­¢é€’å½’ï¼Œæ±‚è§£å¹¶è¿”å›å…·ä½“å€¼</li>
  <li>åˆå¹¶(Combine)ï¼šæ­¥éª¤å°†å­é—®é¢˜çš„è§£ç»„åˆæˆåŸé—®é¢˜çš„è§£</li>
</ul>

<p>åˆ†æ²»çš„æ–¹æ³•å¾€å¾€å¯ä»¥ç”¨é€’å½’å¼å­æ¥è¡¨ç¤ºï¼Œèƒ½å†™å‡ºé€’å½’å¼ï¼Œé—®é¢˜åŸºæœ¬å°±å·²ç»è§£å†³äº†ï¼Œå‰©ä¸‹çš„å°±æ˜¯æ•²å‡ºä»£ç ï¼Œæ¯”å¦‚<code class="language-plaintext highlighter-rouge">Merge Sort</code>çš„é€’å½’å¼å¦‚ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T(n)=O(1) (n=1)
T(n)=2T(n/2)+O(n) (n&gt;1)
æ±‚è§£å¯å¾—T(n)=O(nlgn)ï¼Œå³ä¸ºå½’å¹¶æ’åºçš„æ—¶é—´å¤æ‚åº¦
</code></pre></div></div>

<h3 id="æœ€å¤§è¿ç»­å­æ•°ç»„å’Œ">æœ€å¤§è¿ç»­å­æ•°ç»„å’Œ</h3>
<h4>é—®é¢˜æè¿°ï¼š</h4>
<p>æ±‚æ•°ç»„<code class="language-plaintext highlighter-rouge">{13,-3,-25,20,-3,-16,-23,18,20,-7,12,-5,-22,15,-4,7}</code>çš„å’Œæœ€å¤§çš„æœ€å¤§è¿ç»­å­æ•°ç»„ã€‚</p>

<h4>è§£æ³•ä¸€ï¼šæš´åŠ›æœç´¢</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private static void violentSearch(int[] array) {
    int maxSum = 0;
    for (int i = 0; i &lt; array.length; i++) {
        int temp = 0;
        for (int j = i; j &lt; array.length; j++) {
            temp += array[j];
            if (temp &gt; maxSum) {
                maxSum = temp;
            }
        }
    }
    System.out.println("maxSum:" + maxSum);
}
</code></pre></div></div>

<p>è¾“å‡ºç»“æœæ˜¯43ï¼Œå¾ˆæ˜æ˜¾è¿™æ˜¯ä¸€ç§æ—¶é—´å¤æ‚åº¦è¾ƒé«˜çš„åšæ³•ã€‚</p>

<h4>è§£æ³•äºŒï¼šåˆ†æ²»ç­–ç•¥</h4>

<p>è¿ç”¨åˆ†æ²»ç­–ç•¥çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ•°ç»„ä¸­åˆ†ï¼Œç„¶åé—®é¢˜å˜ä¸ºï¼Œæ±‚å·¦å­æ•°ç»„çš„æœ€å¤§è¿ç»­å’Œï¼Œå³å­æ•°ç»„çš„æœ€å¤§è¿ç»­å’Œï¼Œä»¥åŠè·¨è¶Šä¸­åˆ†ç‚¹çš„æœ€å¤§è¿ç»­åï¼Œç„¶åæ±‚å‡ºä¸‰è€…ä¸­çš„æœ€å¤§å€¼ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private static int divideAndConquer(int[] array, int start, int end) {
    if (start == end) {
        return array[start];
    } else {
        int mid = (start + end) / 2;
        int max_right = divideAndConquer(array, mid + 1, end);
        int max_left = max_right;
        if (start &lt; mid - 1) {
            max_left = divideAndConquer(array, start, mid - 1);
        }
        int max_mid = findMaxCrossingMid(array, start, mid, end);
        if (max_left &lt; max_right) {
            max_left = max_right;
        }
        if (max_left &lt; max_mid) {
            max_left = max_mid;
        }
        return max_left;
    }
}

private static int findMaxCrossingMid(int[] array, int start, int mid, int end) {
    int result = array[mid];
    int left = findMaxBackward(array, mid - 1, start);
    int right = findMaxForward(array, mid + 1, end);
    if (left &gt; 0) {
        result += left;
    }
    if (right &gt; 0) {
        result += right;
    }
    return result;
}

private static int findMaxForward(int[] array, int start, int end) {
    if (start &gt; end) {
        return 0;
    }
    int sum = array[start];
    int max = array[start];
    for (int i = start + 1; i &lt;= end; i++) {
        sum += array[i];
        if (sum &gt; max) {
            max = sum;
        }
    }
    return max;
}

private static int findMaxBackward(int[] array, int start, int end) {
    if (start &lt; end) {
        return 0;
    }
    int sum = array[start];
    int max = array[start];
    for (int i = start - 1; i &gt;= end; i--) {
        sum += array[i];
        if (sum &gt; max) {
            max = sum;
        }
    }
    return max;
}
</code></pre></div></div>

<p>ç»“æœä¸º43ï¼Œä¸ä¹¦ä¸Šä¸åŒï¼Œè¿™é‡Œæˆ‘ä¸“é—¨å†™äº†<code class="language-plaintext highlighter-rouge">findMaxForward()</code>å’Œ<code class="language-plaintext highlighter-rouge">findMaxBackWard()</code>ä¸¤ä¸ªå°æ–¹æ³•ï¼Œè™½ç„¶å¯¼è‡´ä»£ç è¾ƒé•¿ï¼Œä½†æˆ‘ä¸ªäººè®¤ä¸ºè¿™æ ·çš„å†™æ³•æ›´åŠ æ¸…æ™°ï¼Œå‡ºäº†é—®é¢˜å¥½å‘ç°ã€‚</p>
:ET